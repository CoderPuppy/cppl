// Generated by LiveScript 1.2.0
(function(){
  var A, P, U, hat, runtime, baseReceiveFn, Object, Call, NativeFunction, slice$ = [].slice;
  A = require('./ast');
  P = require('./primitives');
  U = require('./userdata');
  hat = require('hat');
  runtime = function(){
    var R, proto, toStrFn, newFn, extendFn;
    R = new runtime.Object;
    R.setCell(P.sym('runtime'), R);
    R.NativeFunction = new runtime.Object;
    proto = new runtime.Object;
    R.NativeFunction.setCell(P.sym('proto'), proto);
    R.setCell(P.sym('NativeFunction'), R.NativeFunction);
    R.Base = new runtime.Object;
    R.Base.setCell(P.sym('runtime'), R);
    R.setCell(P.sym('Base'), R.Base);
    R.nil = R.Base.derivative();
    toStrFn = R.NativeFunction.send('proto').derivative();
    toStrFn.userdata = new runtime.NativeFunction(function(call){
      var str;
      str = R.send('create-str');
      str.userdata = P.str('nil');
      return str;
    });
    R.setCell(P.sym('nil'), R.nil);
    R.Mixin = R.Base.derivative();
    R.setCell(P.sym('Mixin'), R.Mixin);
    R.DefaultBehaviour = R.Mixin.derivative();
    R.Kind = new runtime.Object;
    proto = new runtime.Object;
    newFn = R.NativeFunction.send('proto').derivative();
    newFn.userdata = new runtime.NativeFunction(function(call){});
    proto.setCell(P.sym('new'), newFn);
    extendFn = R.NativeFunction.send('proto').derivative();
    extendFn.userdata = new runtime.NativeFunction(function(call){});
    proto.setCell(P.sym('extend'), extendFn);
    R.Kind.setCell(P.sym('proto'), proto);
    R.Kind.deriveFrom(proto);
    R.Something = R.Kind.send('new');
    R.Kind.cell(P.sym('proto')).send('extend', R.Something);
    return R;
  };
  baseReceiveFn = function(call){
    var self, msg, args, val;
    self = call.receiver;
    msg = call.msg;
    args = msg.args;
    console.log(msg);
    val = self.cell(msg.id);
    if (val != null) {
      return val;
    } else {
      return self.send('runtime').send('nil');
    }
  };
  runtime.Object = Object = (function(superclass){
    var prototype = extend$((import$(Object, superclass).displayName = 'Object', Object), superclass).prototype, constructor = Object;
    function Object(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.cells = {};
      this$.srcs = [];
      this$._id = hat();
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.id = function(){
      if (this.userdata != null) {
        return this.userdata.id();
      } else {
        return this._id;
      }
    };
    prototype.toString = function(){
      if (this.userdata != null) {
        return this.userdata.toString();
      } else {
        return this.send('to-string').toString();
      }
    };
    prototype.wrapFn = function(){
      return function(){
        var args;
        args = slice$.call(arguments);
        return this.send.apply(this, ['()'].concat(slice$.call(args)));
      };
    };
    prototype.deriveFrom = function(src){
      if (this.srcs.indexOf(src) === -1) {
        this.srcs.push(src);
        return this;
      } else {
        throw new Error('Already derived from: ' + src);
      }
    };
    prototype.derivative = function(){
      var o;
      o = new constructor;
      o.deriveFrom(this);
      return o;
    };
    prototype.setCell = function(u, o){
      if (!(u instanceof U.UserData)) {
        throw new Error('Key must be a userdata');
      }
      if (!(o instanceof runtime.Object)) {
        throw new Error('Val must be an object');
      }
      this.cells[u.id()] = o;
      return this;
    };
    prototype.cell = function(u){
      var val, i$, ref$, len$, src;
      val = this.cells[u.id()];
      if (val != null) {
        return val;
      } else {
        for (i$ = 0, len$ = (ref$ = this.srcs).length; i$ < len$; ++i$) {
          src = ref$[i$];
          val = src.cell(u);
          if (val != null) {
            return val;
          }
        }
      }
    };
    prototype.send = function(id){
      var args, ref$;
      args = slice$.call(arguments, 1);
      return (ref$ = runtime.Call).fromArgs.apply(ref$, [this, id].concat(slice$.call(args))).send();
    };
    prototype.receive = function(call){
      var callObj;
      if (this.metafn != null) {
        callObj = this.metafn.send('runtime').send('create-call');
        callObj.userdata = call;
        return this.metafn.send('()', callObj);
      } else {
        return baseReceiveFn(call);
      }
    };
    return Object;
  }(U.UserData));
  runtime.Call = Call = (function(superclass){
    var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
    function Call(ground, receiver, msg, seq){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.ground = ground;
      this$.receiver = receiver;
      this$.msg = msg;
      this$.seq = seq != null
        ? seq
        : A.msgSeq(this$.msg);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.send = function(){
      return this.receiver.receive(this);
    };
    Call.fromArgs = function(receiver, id){
      var args, ground, i$, len$, i, arg;
      args = slice$.call(arguments, 2);
      ground = new runtime.Object;
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        i = i$;
        arg = args[i$];
        ground.setCell(P.sym("--runtime.Call::from-args/ground/" + i), arg);
      }
      return new constructor(ground, receiver, A.msg(P.sym(id), args.map(function(_, i){
        return A.msg(P.sym("--runtime.Call::from-args/ground/" + i));
      })));
    };
    return Call;
  }(U.UserData));
  runtime.NativeFunction = NativeFunction = (function(superclass){
    var prototype = extend$((import$(NativeFunction, superclass).displayName = 'NativeFunction', NativeFunction), superclass).prototype, constructor = NativeFunction;
    function NativeFunction(fn){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.fn = fn;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    return NativeFunction;
  }(U.UserData));
  module.exports = runtime;
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
