// Generated by LiveScript 1.2.0
(function(){
  var M, U, A, T, P, parse;
  M = require('mona-parser');
  U = {
    joined: function(joiner, part){
      return M.sequence(function(s){
        var first, rest;
        first = s(part);
        rest = s(M.collect(M.and(joiner, part)));
        return M.value([first].concat(rest));
      });
    }
  };
  A = require('./ast');
  T = {
    id: function(){
      return M.label(M.bind(M.or(M.string('{}'), M.string('[]'), M.stringOf(M.collect(M.noneOf(['.', ',', ' ', '"', '\'', '(', ')', '[', ']', '{', '}', '\n', '\r', '\t', '#']), {
        min: 1
      }))), function(it){
        return M.value(A.id(it));
      }), 'identifier');
    },
    sep: function(){
      return M.label(M.bind(T.i(), function(it){
        if (it.length > 0) {
          return M.value(it);
        } else {
          return M.fail('expected seperator');
        }
      }), 'seperator');
    },
    ws: function(){
      return M.label(M.collect(M.or(M.string(' '), M.string('\t'), M.string('\n'), M.string('\r'))), 'whitespace');
    },
    i: function(){
      return M.label(M.or(M.stringOf(M.collect(M.between(T.ws(), T.ws(), T.comment()), {
        min: 1
      })), T.ws()), 'ignored');
    },
    comment: function(){
      return M.or(T.lineComment(), T.blockComment());
    },
    lineComment: function(){
      return M.label(M.sequence(function(s){
        var str;
        str = '';
        str += s(M.string('#'));
        str += s(M.stringOf(M.collect(M.noneOf(['\n', '\r']))));
        str += s(M.or(M.collect(M.or(M.string('\n'), M.string('\r')), {
          min: 1,
          max: 2
        }), M.eof()));
        return M.value(str);
      }), 'line comment');
    },
    blockComment: function(){
      return M.label(M.sequence(function(s){
        var str;
        str = '';
        str += s(M.string('/#'));
        str += s(M.stringOf(M.collect(M.or(M.noneOf(['/#', '#/']), T.blockComment()))));
        str += s(M.string('#/'));
        return M.value(str);
      }), 'block comment');
    },
    string: function(){
      return M.label(M.sequence(function(s){
        var quote, contents;
        quote = s(M.or(M.string('"'), M.string('\'')));
        contents = s(M.stringOf(M.collect(M.or(M.string("\\" + quote), M.noneOf([quote])))));
        s(M.string(quote));
        return M.value(A.str(contents));
      }), 'string');
    }
  };
  P = {
    start: function(){
      return M.between(T.i(), T.i(), M.or(P.messageSeq(), M.value(A.msgSeq())));
    },
    messageSeq: function(){
      return M.label(M.sequence(function(s){
        var first, rest;
        first = s(P.message());
        rest = s(M.collect(P.restMessage()));
        return M.value(A.msgSeq([first].concat(rest)));
      }), 'message sequence');
    },
    restMessage: function(){
      return M.label(M.or(M.and(T.sep(), P.message()), P.resetMessage(), P.applyMessage()), 'rest message');
    },
    resetMessage: function(){
      return M.label(M.bind(M.string('.'), function(){
        return M.value(A.msg(A.id('.')));
      }), 'reset message');
    },
    applyMessage: function(){
      return M.label(M.bind(P.args(true), function(it){
        return M.value(A.msg(A.id('apply'), it));
      }), 'apply message');
    },
    message: function(){
      return M.label(M.or(P.sugar(), P.resetMessage(), P.applyMessage(), M.sequence(function(s){
        var id, args;
        id = s(M.or(T.id(), T.string()));
        args = s(P.args());
        return M.value(A.msg(id, args));
      })), 'message');
    },
    sugar: function(){
      return M.or(P.symbol(), P.array(), P.map());
    },
    symbol: function(){
      return M.label(M.bind(M.and(M.string(':'), T.id()), function(it){
        return M.value(A.msg(A.id('internal:createSymbol'), [A.msgSeq([A.msg(it)])]));
      }), 'symbol');
    },
    array: function(){
      return M.label(M.unless(M.string('[]'), M.bind(M.between(M.and(M.string('['), T.i()), M.and(T.i(), M.string(']')), M.delay(P.messageList)), function(it){
        return M.value(A.msg(A.id('[]'), it));
      })), 'array');
    },
    map: function(){
      return M.label(M.unless(M.string('{}'), M.bind(M.between(M.and(M.string('{'), T.i()), M.and(T.i(), M.string('}')), M.delay(P.messageList)), function(it){
        return M.value(A.msg(A.id('{}'), it));
      })), 'map');
    },
    args: function(needed){
      var parser;
      needed == null && (needed = false);
      parser = M.between(M.string('('), M.string(')'), P.messageList());
      if (needed) {
        return parser;
      } else {
        return M.or(parser, M.value([]));
      }
    },
    messageList: function(){
      return M.or(U.joined(M.and(M.string(','), T.i()), P.messageSeq()), M.and(T.i(), M.value([])));
    }
  };
  exports.parser = P;
  exports.tokenizer = T;
  parse = function(txt){
    return M.parse(P.start(), txt);
  };
  exports.parse = parse;
}).call(this);
